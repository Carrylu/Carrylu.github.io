<!doctype html>
<html lang="en-us">
  <head>
    <title>Map接口 // My New Hugo Site</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.55.6" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://Carrylu.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Map接口"/>
<meta name="twitter:description" content="双列集合框架：map 1.常用实现类结构 |----Map:双列数据，存储key-value对的数据 ---类似于高中的函数：y = f(x) * |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value * |----LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。 * 原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。 * 对于频繁的遍历操作，此类执行效率高于HashMap。 * |----TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序 * 底层使用红黑树 * |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value * |----Properties:常用来处理配置文件。key和value都是String类型 * * * HashMap的底层：数组&#43;链表 （jdk7及之前) * 数组&#43;链表&#43;红黑树 （jdk 8)  2.存储结构的理解 &gt;Map中的key:无序的、不可重复的，使用Set存储所的key ---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例) &gt;Map中的value:无序的、可重复的，使用Collection存储所的value ---&gt;value所在的类要重写equals() &gt; 一个键值对：key-value构成了一个Entry对象。 &gt;Map中的entry:无序的、不可重复的，使用Set存储所的entry  图示：
3.常用方法 * 添加：put(Object key,Object value) * 删除：remove(Object key) * 修改：put(Object key,Object value) * 查询：get(Object key) * 长度：size() * 遍历：keySet() / values() / entrySet()  4.内存结构说明（难点） 4."/>

    <meta property="og:title" content="Map接口" />
<meta property="og:description" content="双列集合框架：map 1.常用实现类结构 |----Map:双列数据，存储key-value对的数据 ---类似于高中的函数：y = f(x) * |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value * |----LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。 * 原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。 * 对于频繁的遍历操作，此类执行效率高于HashMap。 * |----TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序 * 底层使用红黑树 * |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value * |----Properties:常用来处理配置文件。key和value都是String类型 * * * HashMap的底层：数组&#43;链表 （jdk7及之前) * 数组&#43;链表&#43;红黑树 （jdk 8)  2.存储结构的理解 &gt;Map中的key:无序的、不可重复的，使用Set存储所的key ---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例) &gt;Map中的value:无序的、可重复的，使用Collection存储所的value ---&gt;value所在的类要重写equals() &gt; 一个键值对：key-value构成了一个Entry对象。 &gt;Map中的entry:无序的、不可重复的，使用Set存储所的entry  图示：
3.常用方法 * 添加：put(Object key,Object value) * 删除：remove(Object key) * 修改：put(Object key,Object value) * 查询：get(Object key) * 长度：size() * 遍历：keySet() / values() / entrySet()  4.内存结构说明（难点） 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Carrylu.github.io/post/map/" />
<meta property="article:published_time" content="2019-07-05T23:23:59&#43;08:00"/>
<meta property="article:modified_time" content="2019-07-05T23:23:59&#43;08:00"/>


  </head>
  <body>
    <header class="app-header">
      <a href="https://Carrylu.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>My New Hugo Site</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Map接口</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jul 5, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      

<h1 id="双列集合框架-map">双列集合框架：map</h1>

<h2 id="1-常用实现类结构">1.常用实现类结构</h2>

<pre><code class="language-java">|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)
*       |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value
*              |----LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。
*                    原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。
*                    对于频繁的遍历操作，此类执行效率高于HashMap。
*       |----TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序
*                      底层使用红黑树
*       |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value
*              |----Properties:常用来处理配置文件。key和value都是String类型
*
*
*      HashMap的底层：数组+链表  （jdk7及之前)
*                    数组+链表+红黑树 （jdk 8)
</code></pre>

<h2 id="2-存储结构的理解">2.存储结构的理解</h2>

<pre><code class="language-java">&gt;Map中的key:无序的、不可重复的，使用Set存储所的key  ---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例)
&gt;Map中的value:无序的、可重复的，使用Collection存储所的value ---&gt;value所在的类要重写equals()
&gt; 一个键值对：key-value构成了一个Entry对象。
&gt;Map中的entry:无序的、不可重复的，使用Set存储所的entry
</code></pre>

<p>图示：</p>

<p><img src="https://Carrylu.github.io/post/map.png" alt="map-photo" /></p>

<h2 id="3-常用方法">3.常用方法</h2>

<pre><code class="language-java">* 添加：put(Object key,Object value)
* 删除：remove(Object key)
* 修改：put(Object key,Object value)
* 查询：get(Object key)
* 长度：size()
* 遍历：keySet() / values() / entrySet()
</code></pre>

<h2 id="4-内存结构说明-难点">4.内存结构说明（难点）</h2>

<h3 id="4-1-hashmap在jdk7中实现原理">4.1 HashMap在jdk7中实现原理：</h3>

<pre><code class="language-java">HashMap map = new HashMap():
*      在实例化以后，底层创建了长度是16的一维数组Entry[] table。
*      ...可能已经执行过多次put...
*      map.put(key1,value1):
*      首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。
*      如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1
*      如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：
*              如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2
*              如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：
*                      如果equals()返回false:此时key1-value1添加成功。----情况3
*                      如果equals()返回true:使用value1替换value2。
*
*      补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。
*
*     在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原的数据复制过来。
</code></pre>

<h3 id="4-2-hashmap在jdk8中相较于jdk7在底层实现方面的不同">4.2 HashMap在jdk8中相较于jdk7在底层实现方面的不同：</h3>

<pre><code class="language-java">1. new HashMap():底层没创建一个长度为16的数组
2. jdk 8底层的数组是：Node[],而非Entry[]
3. 首次调用put()方法时，底层创建长度为16的数组
4. jdk7底层结构只：数组+链表。jdk8中底层结构：数组+链表+红黑树。
4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）
4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。
</code></pre>

<h3 id="4-3-hashmap底层典型属性的属性的说明">4.3 HashMap底层典型属性的属性的说明：</h3>

<pre><code class="language-java">DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16
DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75
threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12
TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8
MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64
</code></pre>

<h2 id="5-treemap的使用">5. TreeMap的使用</h2>

<pre><code class="language-java">//向TreeMap中添加key-value，要求key必须是由同一个类创建的对象
//因为要照key进行排序：自然排序 、定制排序
</code></pre>

<h2 id="6-使用properties读取配置文件">6.使用properties读取配置文件</h2>

<pre><code class="language-java">//Properties:常用来处理配置文件。key和value都是String类型
public static void main(String[] args)  {
    FileInputStream fis = null;
    try {
        Properties pros = new Properties();

        fis = new FileInputStream(&quot;jdbc.properties&quot;);
        pros.load(fis);//加载流对应的文件

        String name = pros.getProperty(&quot;name&quot;);
        String password = pros.getProperty(&quot;password&quot;);

        System.out.println(&quot;name = &quot; + name + &quot;, password = &quot; + password);
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if(fis != null){
            try {
                fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }

        }
    }

</code></pre>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
