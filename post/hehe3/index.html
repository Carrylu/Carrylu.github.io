<!doctype html>
<html lang="en-us">
  <head>
    <title>List接口 // My New Hugo Site</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.55.6" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://Carrylu.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="List接口"/>
<meta name="twitter:description" content="Collection接口子接口：List接口 1、存储的数据特点：有序的、可重复的数据 2、常用方法 增：add(); 删：remove(int index); / remove(Object obj); 改：set(int index,Object ele); //按照索引查找 查：get(int index); 插：add(int index,Object ele); 长度：size(); 遍历：① Iterator迭代器方式 ② 增强for循环 ③ 普通的循环  ① Iterator迭代器方式
Iterator iterator=list.iterator(); while(iterator.hasnext()){ System.out.println(iterator.next()); }  ② 增强for循环
for(Object obj: list){ System.out.println(obj); }  ③ 普通的循环
String[] arr=new String[]{&quot;AA&quot;,&quot;AA&quot;,&quot;AA&quot;}; for(int i=0;i&lt;arr.length;i&#43;&#43;){ System.out.println(arr[i]); }  3、常用实现类 |----Collection接口：单列集合，用来存储一个一个的对象 * |----List接口：存储序的、可重复的数据。 --&gt;“动态”数组,替换原的数组 * |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储 * |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储 * |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储  4、源码分析 4.1 Arraylist源码分析 * 2."/>

    <meta property="og:title" content="List接口" />
<meta property="og:description" content="Collection接口子接口：List接口 1、存储的数据特点：有序的、可重复的数据 2、常用方法 增：add(); 删：remove(int index); / remove(Object obj); 改：set(int index,Object ele); //按照索引查找 查：get(int index); 插：add(int index,Object ele); 长度：size(); 遍历：① Iterator迭代器方式 ② 增强for循环 ③ 普通的循环  ① Iterator迭代器方式
Iterator iterator=list.iterator(); while(iterator.hasnext()){ System.out.println(iterator.next()); }  ② 增强for循环
for(Object obj: list){ System.out.println(obj); }  ③ 普通的循环
String[] arr=new String[]{&quot;AA&quot;,&quot;AA&quot;,&quot;AA&quot;}; for(int i=0;i&lt;arr.length;i&#43;&#43;){ System.out.println(arr[i]); }  3、常用实现类 |----Collection接口：单列集合，用来存储一个一个的对象 * |----List接口：存储序的、可重复的数据。 --&gt;“动态”数组,替换原的数组 * |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储 * |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储 * |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储  4、源码分析 4.1 Arraylist源码分析 * 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Carrylu.github.io/post/hehe3/" />
<meta property="article:published_time" content="2019-07-02T23:39:02&#43;08:00"/>
<meta property="article:modified_time" content="2019-07-02T23:39:02&#43;08:00"/>


  </head>
  <body>
    <header class="app-header">
      <a href="https://Carrylu.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>My New Hugo Site</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">List接口</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jul 2, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      

<h1 id="collection接口子接口-list接口">Collection接口子接口：List接口</h1>

<p><img src="https://Carrylu.github.io/post/collection.png" alt="collection-photo" /></p>

<h2 id="1-存储的数据特点-有序的-可重复的数据">1、存储的数据特点：有序的、可重复的数据</h2>

<h2 id="2-常用方法">2、常用方法</h2>

<pre><code class="language-java">增：add();
删：remove(int index); / remove(Object obj);
改：set(int index,Object ele);  //按照索引查找
查：get(int index);
插：add(int index,Object ele);  
长度：size();
遍历：① Iterator迭代器方式
      ② 增强for循环
      ③ 普通的循环
</code></pre>

<p>① Iterator迭代器方式</p>

<pre><code class="language-java">Iterator iterator=list.iterator();
while(iterator.hasnext()){
    System.out.println(iterator.next());
}
</code></pre>

<p>② 增强for循环</p>

<pre><code class="language-java">for(Object obj: list){
    System.out.println(obj);
}
</code></pre>

<p>③ 普通的循环</p>

<pre><code class="language-java">String[] arr=new String[]{&quot;AA&quot;,&quot;AA&quot;,&quot;AA&quot;};
for(int i=0;i&lt;arr.length;i++){
    System.out.println(arr[i]);
}
</code></pre>

<h2 id="3-常用实现类">3、常用实现类</h2>

<pre><code class="language-java">|----Collection接口：单列集合，用来存储一个一个的对象
*  |----List接口：存储序的、可重复的数据。  --&gt;“动态”数组,替换原的数组
*      |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储
*      |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储
*      |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储
</code></pre>

<h2 id="4-源码分析">4、源码分析</h2>

<h3 id="4-1-arraylist源码分析">4.1 Arraylist源码分析</h3>

<pre><code class="language-java">*   2.1 jdk 7情况下
*      ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData
*      list.add(123);//elementData[0] = new Integer(123);
*      ...
*      list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。
*      默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。
*
*      结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)
*
*   2.2 jdk 8中ArrayList的变化：
*      ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没创建长度为10的数组
*
*      list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]
*      ...
*      后续的添加和扩容操作与jdk 7 无异。
*   2.3 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象
*            的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。
*

</code></pre>

<h3 id="4-2-linkedlist-源码分析">4.2 Linkedlist 源码分析</h3>

<pre><code class="language-java">*      LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null
*      list.add(123);//将123封装到Node中，创建了Node对象。
*
*      其中，Node定义为：体现了LinkedList的双向链表的说法
*      private static class Node&lt;E&gt; {
            E item;
            Node&lt;E&gt; next;
            Node&lt;E&gt; prev;

            Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
            }
        }

</code></pre>

<h3 id="4-3-vector-源码分析">4.3 Vector 源码分析</h3>

<pre><code class="language-java">//jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。
//在扩容方面，默认扩容为原来的数组长度的2倍。
</code></pre>

<h2 id="5-存储的元素的要求">5、存储的元素的要求：</h2>

<p>添加的对象，所在的类要重写equals()方法</p>

<pre><code>[面试题]
*  面试题：ArrayList、LinkedList、Vector者的异同？
*  同：三个类都是实现了List接口，存储数据的特点相同：存有序的、可重复的数据
*  不同：ArrayList底层使用的是数组，线程不安全，效率高
        Linkedlist底层使用的是链表，如果需要频繁插入删除，选择Linkedlist效率高
        Vertor底层使用的数组，线程安全，效率低
</code></pre>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
