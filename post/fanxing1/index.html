<!doctype html>
<html lang="en-us">
  <head>
    <title>自定义泛型类、泛型接口、泛型方法 // My New Hugo Site</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.55.6" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://Carrylu.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="自定义泛型类、泛型接口、泛型方法"/>
<meta name="twitter:description" content="举例： 【Order.java】
public class Order&lt;T&gt; { String orderName; int orderId; //类的内部结构就可以使用类的泛型 T orderT; public Order(){ //编译不通过 // T[] arr = new T[10]; //编译通过 T[] arr = (T[]) new Object[10]; } public Order(String orderName,int orderId,T orderT){ this.orderName = orderName; this.orderId = orderId; this.orderT = orderT; } //如下的个方法都不是泛型方法 public T getOrderT(){ return orderT; } public void setOrderT(T orderT){ this.orderT = orderT; } @Override public String toString() { return &quot;Order{&quot; &#43; &quot;orderName=&#39;&quot; &#43; orderName &#43; &#39;\&#39;&#39; &#43; &quot;, orderId=&quot; &#43; orderId &#43; &quot;, orderT=&quot; &#43; orderT &#43; &#39;}&#39;; } //静态方法中不能使用类的泛型。 // public static void show(T orderT){ // System."/>

    <meta property="og:title" content="自定义泛型类、泛型接口、泛型方法" />
<meta property="og:description" content="举例： 【Order.java】
public class Order&lt;T&gt; { String orderName; int orderId; //类的内部结构就可以使用类的泛型 T orderT; public Order(){ //编译不通过 // T[] arr = new T[10]; //编译通过 T[] arr = (T[]) new Object[10]; } public Order(String orderName,int orderId,T orderT){ this.orderName = orderName; this.orderId = orderId; this.orderT = orderT; } //如下的个方法都不是泛型方法 public T getOrderT(){ return orderT; } public void setOrderT(T orderT){ this.orderT = orderT; } @Override public String toString() { return &quot;Order{&quot; &#43; &quot;orderName=&#39;&quot; &#43; orderName &#43; &#39;\&#39;&#39; &#43; &quot;, orderId=&quot; &#43; orderId &#43; &quot;, orderT=&quot; &#43; orderT &#43; &#39;}&#39;; } //静态方法中不能使用类的泛型。 // public static void show(T orderT){ // System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Carrylu.github.io/post/fanxing1/" />
<meta property="article:published_time" content="2019-07-06T22:49:11&#43;08:00"/>
<meta property="article:modified_time" content="2019-07-06T22:49:11&#43;08:00"/>


  </head>
  <body>
    <header class="app-header">
      <a href="https://Carrylu.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>My New Hugo Site</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">自定义泛型类、泛型接口、泛型方法</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jul 6, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div></div>
    </header>
    <div class="post-content">
      

<h2 id="举例">举例：</h2>

<p>【Order.java】</p>

<pre><code class="language-java">public class Order&lt;T&gt; {

    String orderName;
    int orderId;

    //类的内部结构就可以使用类的泛型

    T orderT;

    public Order(){
        //编译不通过
//        T[] arr = new T[10];
        //编译通过
        T[] arr = (T[]) new Object[10];
    }

    public Order(String orderName,int orderId,T orderT){
        this.orderName = orderName;
        this.orderId = orderId;
        this.orderT = orderT;
    }

    //如下的个方法都不是泛型方法
    public T getOrderT(){
        return orderT;
    }

    public void setOrderT(T orderT){
        this.orderT = orderT;
    }

    @Override
    public String toString() {
        return &quot;Order{&quot; +
                &quot;orderName='&quot; + orderName + '\'' +
                &quot;, orderId=&quot; + orderId +
                &quot;, orderT=&quot; + orderT +
                '}';
    }
    //静态方法中不能使用类的泛型。
//    public static void show(T orderT){
//        System.out.println(orderT);
//    }

    public void show(){
        //编译不通过
//        try{
//
//
//        }catch(T t){
//
//        }

    }

    //泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没任何关系。
    //换句话说，泛型方法所属的类是不是泛型类都没关系。
    //泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。
    public static &lt;E&gt;  List&lt;E&gt; copyFromArrayToList(E[] arr){

        ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();

        for(E e : arr){
            list.add(e);
        }
        return list;

    }
}
</code></pre>

<p>【SubOrder.java】</p>

<pre><code class="language-java">public class SubOrder extends Order&lt;Integer&gt; {//SubOrder:不是泛型类


    public static &lt;E&gt; List&lt;E&gt; copyFromArrayToList(E[] arr){

        ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();

        for(E e : arr){
            list.add(e);
        }
        return list;

    }


}
</code></pre>

<p>//实例化时，如下的代码是错误的</p>

<pre><code class="language-java">SubOrder&lt;Integer&gt; o = new SubOrder&lt;&gt;();
</code></pre>

<p>【SubOrder1.java】</p>

<pre><code class="language-java">public class SubOrder1&lt;T&gt; extends Order&lt;T&gt; {//SubOrder1&lt;T&gt;:仍然是泛型类

}

</code></pre>

<p>【测试】</p>

<pre><code class="language-java">@Test
    public void test1(){
        //如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型
        //要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。
        Order order = new Order();
        order.setOrderT(123);
        order.setOrderT(&quot;ABC&quot;);

        //建议：实例化时指明类的泛型
        Order&lt;String&gt; order1 = new Order&lt;String&gt;(&quot;orderAA&quot;,1001,&quot;order:AA&quot;);

        order1.setOrderT(&quot;AA:hello&quot;);

    }

    @Test
    public void test2(){
        SubOrder sub1 = new SubOrder();
        //由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型。
        sub1.setOrderT(1122);

        SubOrder1&lt;String&gt; sub2 = new SubOrder1&lt;&gt;();
        sub2.setOrderT(&quot;order2...&quot;);
    }

    @Test
    public void test3(){

        ArrayList&lt;String&gt; list1 = null;
        ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;();
        //泛型不同的引用不能相互赋值。
//        list1 = list2;

        Person p1 = null;
        Person p2 = null;
        p1 = p2;


    }

    //测试泛型方法
    @Test
    public void test4(){
        Order&lt;String&gt; order = new Order&lt;&gt;();
        Integer[] arr = new Integer[]{1,2,3,4};
        //泛型方法在调用时，指明泛型参数的类型。
        List&lt;Integer&gt; list = order.copyFromArrayToList(arr);

        System.out.println(list);
    }
</code></pre>

<h2 id="2-注意点">2.注意点</h2>

<p><img src="fanxing2.png" alt="" />
<img src="fanxing3.png" alt="" /></p>

<h2 id="3-应用场景举例">3.应用场景举例</h2>

<p>【DAO.java】:定义了操作数据库中的表的通用操作。   ORM思想(数据库中的表和Java中的类对应)</p>

<pre><code class="language-java">public class DAO&lt;T&gt; {//表的共性操作的DAO

    //添加一条记录
    public void add(T t){

    }

    //删除一条记录
    public boolean remove(int index){

        return false;
    }

    //修改一条记录
    public void update(int index,T t){

    }

    //查询一条记录
    public T getIndex(int index){

        return null;
    }

    //查询多条记录
    public List&lt;T&gt; getForList(int index){

        return null;
    }

    //泛型方法
    //举例：获取表中一共有多少条记录？获取最大的员工入职时间？
    public &lt;E&gt; E getValue(){

        return null;
    }

}
</code></pre>

<p>【CustomerDAO.java】:</p>

<pre><code class="language-java">public class CustomerDAO extends DAO&lt;Customer&gt;{//只能操作某一个表的DAO
}
</code></pre>

<p>【StudentDAO.java】:</p>

<pre><code class="language-java">public class StudentDAO extends DAO&lt;Student&gt; {//只能操作某一个表的DAO
}
</code></pre>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
